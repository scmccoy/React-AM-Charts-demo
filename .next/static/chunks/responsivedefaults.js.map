{"version":3,"file":"static/chunks/responsivedefaults.js","sources":["webpack:///./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisFillCircular.js","webpack:///./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisLabelCircular.js","webpack:///./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererCircular.js","webpack:///./node_modules/@amcharts/amcharts4/.internal/charts/axes/GridCircular.js","webpack:///./node_modules/@amcharts/amcharts4/.internal/charts/map/SmallMap.js","webpack:///./node_modules/@amcharts/amcharts4/.internal/charts/map/ZoomControl.js","webpack:///./node_modules/@amcharts/amcharts4/.internal/core/responsive/ResponsiveDefaults.js"],"sourcesContent":["import * as tslib_1 from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { AxisFill } from \"./AxisFill\";\r\nimport { percent } from \"../../core/utils/Percent\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $type from \"../../core/utils/Type\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Provides fill element functionality for circular Axes.\r\n *\r\n * @see {@link IAxisFillCircularEvents} for a list of available events\r\n * @see {@link IAxisFillCircularAdapters} for a list of available Adapters\r\n * @todo Needs description\r\n */\r\nvar AxisFillCircular = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AxisFillCircular, _super);\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param {Axis} axis Axis\r\n     */\r\n    function AxisFillCircular(axis) {\r\n        var _this = _super.call(this, axis) || this;\r\n        _this.className = \"AxisFillCircular\";\r\n        _this.element = _this.paper.add(\"path\");\r\n        _this.radius = percent(100);\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Draws the fill element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    AxisFillCircular.prototype.draw = function () {\r\n        _super.prototype.draw.call(this);\r\n        if (this.axis) {\r\n            var renderer = this.axis.renderer;\r\n            this.fillPath = renderer.getPositionRangePath(this.startPosition, this.endPosition, this.radius, $type.hasValue(this.innerRadius) ? this.innerRadius : renderer.innerRadius, this.cornerRadius);\r\n            this.path = this.fillPath;\r\n        }\r\n    };\r\n    Object.defineProperty(AxisFillCircular.prototype, \"innerRadius\", {\r\n        /**\r\n         * @return {number} Inner radius\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"innerRadius\");\r\n        },\r\n        /**\r\n         * Inner radius of the fill. Relative ([[Percent]]) or absolute (pixels).\r\n         *\r\n         * @param {number | Percent}  value  Inner radius\r\n         */\r\n        set: function (value) {\r\n            this.setPercentProperty(\"innerRadius\", value, true, false, 10, false);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisFillCircular.prototype, \"radius\", {\r\n        /**\r\n         * @return {number} Outer radius\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"radius\");\r\n        },\r\n        /**\r\n         * Outer radius of the fill. Relative ([[Percent]]) or absolute (pixels).\r\n         *\r\n         * @param {number | Percent}  value  Outer radius\r\n         */\r\n        set: function (value) {\r\n            this.setPercentProperty(\"radius\", value, true, false, 10, false);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisFillCircular.prototype, \"cornerRadius\", {\r\n        /**\r\n         * @return {number} Corner radius (px)\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"cornerRadius\");\r\n        },\r\n        /**\r\n         * Corner radius for the fill. In pixels.\r\n         *\r\n         * @param {number}  value  Corner radius (px)\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"cornerRadius\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return AxisFillCircular;\r\n}(AxisFill));\r\nexport { AxisFillCircular };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"AxisFillCircular\"] = AxisFillCircular;\r\n//# sourceMappingURL=AxisFillCircular.js.map","/**\r\n * Axis Label module\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { AxisLabel } from \"./AxisLabel\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport { Percent } from \"../../core/utils/Percent\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Use to create labels on circular axis.\r\n *\r\n * @see {@link IAxisLabelCircularEvents} for a list of available events\r\n * @see {@link IAxisLabelCircularAdapters} for a list of available Adapters\r\n */\r\nvar AxisLabelCircular = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AxisLabelCircular, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function AxisLabelCircular() {\r\n        var _this = _super.call(this) || this;\r\n        /**\r\n         *\r\n         * @type {number}\r\n         * @ignore\r\n         */\r\n        _this.fdx = 0;\r\n        /**\r\n         *\r\n         * @type {number}\r\n         * @ignore\r\n         */\r\n        _this.fdy = 0;\r\n        _this.className = \"AxisLabelCircular\";\r\n        _this.padding(0, 0, 0, 0);\r\n        _this.location = 0.5;\r\n        _this.radius = 0;\r\n        _this.isMeasured = false;\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(AxisLabelCircular.prototype, \"relativeRotation\", {\r\n        /**\r\n         * @return {number} Rotation angle\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"relativeRotation\");\r\n        },\r\n        /**\r\n         * Relative rotation of the label.\r\n         *\r\n         * It is an angle to circle. In case 90, labels will be positioned like rays\r\n         * of light, if 0 - positione along the circle.\r\n         *\r\n         * @param {number} value Rotation angle\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"relativeRotation\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisLabelCircular.prototype, \"radius\", {\r\n        /**\r\n         * @return {number} Distance (px)\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"radius\");\r\n        },\r\n        /**\r\n         * Distance from axis circle to label in pixels or percent.\r\n         *\r\n         * @param {number} value Distance (px or percent)\r\n         */\r\n        set: function (value) {\r\n            this.setPercentProperty(\"radius\", value, true, false, 10, false);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * returns label radius in pixels\r\n     */\r\n    AxisLabelCircular.prototype.pixelRadius = function (axisRadius) {\r\n        var sign = 1;\r\n        if (this.inside) {\r\n            sign = -1;\r\n        }\r\n        return $utils.relativeToValue(this.radius, axisRadius) * sign;\r\n    };\r\n    /**\r\n     * returns label radius in pixels\r\n     */\r\n    AxisLabelCircular.prototype.pixelRadiusY = function (axisRadius, axisRadiusY) {\r\n        var sign = 1;\r\n        if (this.inside) {\r\n            sign = -1;\r\n        }\r\n        var radius = this.radius;\r\n        if ($type.isNumber(radius)) {\r\n            radius *= axisRadiusY / axisRadius;\r\n            return $utils.relativeToValue(radius, axisRadius) * sign;\r\n        }\r\n        else {\r\n            return $utils.relativeToValue(radius, axisRadiusY) * sign;\r\n        }\r\n    };\r\n    /**\r\n     * [fixPosition description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param  {IPoint}  point       Label affixation point\r\n     * @param  {number}  axisRadius  Distance from point (px)\r\n     */\r\n    AxisLabelCircular.prototype.fixPosition = function (angle, axisRadius, axisRadiusY, dx, dy) {\r\n        if (!$type.isNumber(axisRadiusY)) {\r\n            axisRadiusY = axisRadius;\r\n        }\r\n        if (!$type.isNumber(dx)) {\r\n            dx = 0;\r\n        }\r\n        if (!$type.isNumber(dy)) {\r\n            dy = 0;\r\n        }\r\n        var point = { x: axisRadius * $math.cos(angle), y: axisRadiusY * $math.sin(angle) };\r\n        if (this.invalid) {\r\n            this.validate(); //@todo\" check if we need this\r\n        }\r\n        var isNegative = false;\r\n        var realRadius = this.radius;\r\n        if (realRadius instanceof Percent && realRadius.value < 0) {\r\n            isNegative = true;\r\n        }\r\n        else if (realRadius < 0) {\r\n            isNegative = true;\r\n        }\r\n        var relativeRotation = this.relativeRotation;\r\n        var labelRadius = this.pixelRadius(axisRadius);\r\n        // WHEN ROTATED\r\n        if ($type.isNumber(relativeRotation)) {\r\n            this.horizontalCenter = \"none\";\r\n            this.verticalCenter = \"none\";\r\n            angle = $math.fitAngleToRange(angle, -180, 180);\r\n            var pixelWidth = this.bbox.width;\r\n            var pixelHeight = this.bbox.height;\r\n            var pixelPaddingBottom = this.pixelPaddingBottom;\r\n            var pixelPaddingTop = this.pixelPaddingTop;\r\n            var pixelPaddingLeft = this.pixelPaddingLeft;\r\n            var pixelPaddingRight = this.pixelPaddingRight;\r\n            if (angle > 90 || angle < -90) {\r\n                if (relativeRotation == -90) {\r\n                    relativeRotation = 90;\r\n                    pixelWidth = 0;\r\n                }\r\n            }\r\n            else {\r\n                if (relativeRotation == -90) {\r\n                    pixelHeight = -pixelHeight;\r\n                }\r\n                if (relativeRotation == 90) {\r\n                    relativeRotation = -90;\r\n                    pixelWidth = -pixelPaddingLeft - pixelPaddingRight;\r\n                    pixelHeight = -pixelHeight - pixelPaddingTop - pixelPaddingBottom;\r\n                }\r\n            }\r\n            this.rotation = relativeRotation + angle + 90;\r\n            var dH = $math.sin(relativeRotation) / 2;\r\n            var dW = $math.cos(relativeRotation) / 2;\r\n            var rotation = this.rotation;\r\n            this.dx = pixelHeight * dH * $math.sin(rotation) - pixelWidth * dW * $math.cos(rotation);\r\n            this.dy = -pixelHeight * dH * $math.cos(rotation) - pixelWidth * dW * $math.sin(rotation);\r\n            if (!this.inside) {\r\n                labelRadius += (pixelHeight + pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelWidth + pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\r\n            }\r\n            else {\r\n                if (angle > 90 || angle < -90) {\r\n                    labelRadius -= (pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\r\n                }\r\n                else {\r\n                    labelRadius += (pixelPaddingBottom + this.bbox.height + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight + this.bbox.width) * $math.sin(relativeRotation);\r\n                }\r\n            }\r\n            point.x += $math.cos(angle) * labelRadius;\r\n            point.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\r\n        }\r\n        else {\r\n            // END OF ROTATED\r\n            this.horizontalCenter = \"middle\";\r\n            this.verticalCenter = \"middle\";\r\n            if (isNegative) {\r\n                this.dx = 0;\r\n                this.dy = 0;\r\n                point.x = (axisRadius + labelRadius) * $math.cos(angle);\r\n                point.y = (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * $math.sin(angle);\r\n            }\r\n            else {\r\n                // we don't use valign for labels because then they would jump while animating. instead we modify dy depending on a y position\r\n                // this math makes dy to be 1 at the top of the circle, 0.5 at the middle and 1 at the bottom\r\n                // @todo with this math doesn't work well with inside = true\r\n                this.dy = this._measuredHeight / 2 * $math.sin(angle); //(1 - (point.y + axisRadiusY) / (2 * axisRadiusY));\r\n                // simmilar with dx\r\n                this.dx = this._measuredWidth / 2 * $math.cos(angle); //(1 - (point.x + axisRadius) / (2 * axisRadius));\r\n                point.x += $math.cos(angle) * labelRadius;\r\n                point.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\r\n            }\r\n        }\r\n        point.x += dx;\r\n        point.y += dy;\r\n        this.fdx = this.dx;\r\n        this.fdy = this.dy;\r\n        this.moveTo(point);\r\n    };\r\n    return AxisLabelCircular;\r\n}(AxisLabel));\r\nexport { AxisLabelCircular };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"AxisLabelCircular\"] = AxisLabelCircular;\r\n//# sourceMappingURL=AxisLabelCircular.js.map","/**\r\n * Module, defining Axis Renderer for circular axes.\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { AxisRenderer } from \"./AxisRenderer\";\r\nimport { AxisFillCircular } from \"./AxisFillCircular\";\r\nimport { GridCircular } from \"./GridCircular\";\r\nimport { AxisLabelCircular } from \"./AxisLabelCircular\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { percent } from \"../../core/utils/Percent\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport * as $type from \"../../core/utils/Type\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * A renderer for circular axis.\r\n */\r\nvar AxisRendererCircular = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AxisRendererCircular, _super);\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param {Axis} axis Related axis\r\n     */\r\n    function AxisRendererCircular() {\r\n        var _this = \r\n        // Init\r\n        _super.call(this) || this;\r\n        /**\r\n         * @ignore\r\n         */\r\n        _this.pixelRadiusReal = 0;\r\n        // axis.layout = \"none\"; // does not trigger redraw when size changes\r\n        _this.layout = \"none\";\r\n        _this.className = \"AxisRendererCircular\";\r\n        _this.isMeasured = false;\r\n        _this.startAngle = -90;\r\n        _this.endAngle = 270;\r\n        _this.useChartAngles = true;\r\n        _this.radius = percent(100);\r\n        _this.isMeasured = false;\r\n        _this.grid.template.location = 0;\r\n        _this.labels.template.location = 0;\r\n        _this.labels.template.radius = 15;\r\n        _this.ticks.template.location = 0;\r\n        _this.ticks.template.pixelPerfect = false;\r\n        _this.tooltipLocation = 0;\r\n        _this.line.strokeOpacity = 0;\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    /**\r\n    * @ignore\r\n    */\r\n    AxisRendererCircular.prototype.setAxis = function (axis) {\r\n        var _this = this;\r\n        _super.prototype.setAxis.call(this, axis);\r\n        axis.isMeasured = false;\r\n        // modify x and y so that tooltip would always be on circle\r\n        var tooltip = axis.tooltip;\r\n        tooltip.adapter.add(\"dx\", function (x, target) {\r\n            var point = $utils.svgPointToSprite({ x: target.pixelX, y: target.pixelY }, _this);\r\n            return _this.pixelRadius * Math.cos(Math.atan2(point.y, point.x)) - point.x;\r\n        });\r\n        tooltip.adapter.add(\"dy\", function (y, target) {\r\n            var point = $utils.svgPointToSprite({ x: target.pixelX, y: target.pixelY }, _this);\r\n            return _this.pixelRadius * Math.sin(Math.atan2(point.y, point.x)) - point.y;\r\n        });\r\n    };\r\n    /**\r\n     * Validates Axis renderer.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    AxisRendererCircular.prototype.validate = function () {\r\n        // so that radius would be updated\r\n        if (this.chart && this.chart.invalid) {\r\n            this.chart.validate();\r\n        }\r\n        _super.prototype.validate.call(this);\r\n    };\r\n    Object.defineProperty(AxisRendererCircular.prototype, \"axisLength\", {\r\n        /**\r\n         * Returns actual length of the Axis, in pixels.\r\n         *\r\n         * @return {number} Length (px)\r\n         */\r\n        get: function () {\r\n            return 2 * Math.PI * this.pixelRadius;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererCircular.prototype, \"radius\", {\r\n        /**\r\n         * @return {number | Percent} Outer radius\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"radius\");\r\n        },\r\n        /**\r\n         * Outer radius of the axis.\r\n         *\r\n         * Can be absolute (px) or relative ([[Percent]]).\r\n         *\r\n         * @param {number | Percent}  value  Outer radius\r\n         */\r\n        set: function (value) {\r\n            if (this.setPercentProperty(\"radius\", value, false, false, 10, false)) {\r\n                if (this.axis) {\r\n                    this.axis.invalidate();\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererCircular.prototype, \"pixelRadius\", {\r\n        /**\r\n         * Outer radius in pixels.\r\n         *\r\n         * @return {number} Outer radius (px)\r\n         */\r\n        get: function () {\r\n            return $utils.relativeRadiusToValue(this.radius, this.pixelRadiusReal) || 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererCircular.prototype, \"innerRadius\", {\r\n        /**\r\n         * @return {number | Percent} Inner radius\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"innerRadius\");\r\n        },\r\n        /**\r\n         * Inner radius of the axis.\r\n         *\r\n         * Can be absolute (px) or relative ([[Percent]]).\r\n         *\r\n         * @param {number | Percent}  value  Inner radius\r\n         */\r\n        set: function (value) {\r\n            if (this.setPercentProperty(\"innerRadius\", value, false, false, 10, false)) {\r\n                if (this.axis) {\r\n                    this.axis.invalidate();\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererCircular.prototype, \"useChartAngles\", {\r\n        /**\r\n         * @return {boolean} Use chart angles\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"useChartAngles\");\r\n        },\r\n        /**\r\n         * Specifies if axis should use its own `startAngle` and `endAngle` or\r\n         * inherit them from relative properties from chart.\r\n         *\r\n         * @default false\r\n         * @param {boolean}  value  Use chart's angles\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"useChartAngles\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererCircular.prototype, \"pixelInnerRadius\", {\r\n        /**\r\n         * Inner radius in pixels.\r\n         *\r\n         * @return {number} Inner radius (px)\r\n         */\r\n        get: function () {\r\n            return $utils.relativeRadiusToValue(this.innerRadius, this.pixelRadiusReal) || 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Converts relative position on axis to point coordinates.\r\n     *\r\n     * @param  {number}  position  Position (0-1)\r\n     * @return {IPoint}            Point\r\n     */\r\n    AxisRendererCircular.prototype.positionToPoint = function (position) {\r\n        var coordinate = this.positionToCoordinate(position);\r\n        var angle = this.startAngle + (this.endAngle - this.startAngle) * coordinate / this.axisLength;\r\n        return { x: this.pixelRadius * $math.cos(angle), y: this.pixelRadius * $math.sin(angle) };\r\n    };\r\n    /**\r\n     * Converts relative position (0-1) on axis to angle in degrees (0-360).\r\n     *\r\n     * @param  {number}  position  Position (0-1)\r\n     * @return {number}            Angle (0-360)\r\n     */\r\n    AxisRendererCircular.prototype.positionToAngle = function (position) {\r\n        var axis = this.axis;\r\n        var arc = (this.endAngle - this.startAngle) / (axis.end - axis.start);\r\n        var angle;\r\n        if (axis.renderer.inversed) {\r\n            angle = this.startAngle + (axis.end - position) * arc;\r\n        }\r\n        else {\r\n            angle = this.startAngle + (position - axis.start) * arc;\r\n        }\r\n        return $math.round(angle, 3);\r\n    };\r\n    /**\r\n     * Updates and positions the axis line element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    AxisRendererCircular.prototype.updateAxisLine = function () {\r\n        var radius = this.pixelRadius;\r\n        var startAngle = this.startAngle;\r\n        var endAngle = this.endAngle;\r\n        var arc = endAngle - startAngle;\r\n        this.line.path = $path.moveTo({ x: radius * $math.cos(startAngle), y: radius * $math.sin(startAngle) }) + $path.arcTo(startAngle, arc, radius, radius);\r\n    };\r\n    /**\r\n     * Updates and positions a grid element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param {Grid}    grid         Grid element\r\n     * @param {number}  position     Starting position\r\n     * @param {number}  endPosition  End position\r\n     */\r\n    AxisRendererCircular.prototype.updateGridElement = function (grid, position, endPosition) {\r\n        position = position + (endPosition - position) * grid.location;\r\n        var point = this.positionToPoint(position);\r\n        if (grid.element) {\r\n            var angle = $math.DEGREES * Math.atan2(point.y, point.x);\r\n            var radius = $utils.relativeRadiusToValue($type.hasValue(grid.radius) ? grid.radius : percent(100), this.pixelRadius);\r\n            var gridInnerRadius = $utils.relativeRadiusToValue(grid.innerRadius, this.pixelRadius);\r\n            grid.zIndex = 0;\r\n            var innerRadius = $utils.relativeRadiusToValue($type.isNumber(gridInnerRadius) ? gridInnerRadius : this.innerRadius, this.pixelRadius, true);\r\n            grid.path = $path.moveTo({ x: innerRadius * $math.cos(angle), y: innerRadius * $math.sin(angle) }) + $path.lineTo({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) });\r\n        }\r\n        this.toggleVisibility(grid, position, 0, 1);\r\n    };\r\n    /**\r\n     * Updates and positions a tick element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param {AxisTick}  tick         Tick element\r\n     * @param {number}    position     Starting position\r\n     * @param {number}    endPosition  End position\r\n     */\r\n    AxisRendererCircular.prototype.updateTickElement = function (tick, position, endPosition) {\r\n        position = position + (endPosition - position) * tick.location;\r\n        var point = this.positionToPoint(position);\r\n        if (tick.element) {\r\n            var radius = this.pixelRadius;\r\n            var angle = $math.DEGREES * Math.atan2(point.y, point.x);\r\n            var tickLength = tick.length;\r\n            if (tick.inside) {\r\n                tickLength = -tickLength;\r\n            }\r\n            tick.zIndex = 1;\r\n            tick.path = $path.moveTo({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) }) + $path.lineTo({ x: (radius + tickLength) * $math.cos(angle), y: (radius + tickLength) * $math.sin(angle) });\r\n        }\r\n        this.toggleVisibility(tick, position, 0, 1);\r\n    };\r\n    /**\r\n     * Updates and positions a label element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param {AxisLabel}  label        Label element\r\n     * @param {number}     position     Starting position\r\n     * @param {number}     endPosition  Ending position\r\n     */\r\n    AxisRendererCircular.prototype.updateLabelElement = function (label, position, endPosition, location) {\r\n        if (!$type.hasValue(location)) {\r\n            location = label.location;\r\n        }\r\n        position = position + (endPosition - position) * location;\r\n        label.fixPosition(this.positionToAngle(position), this.pixelRadius);\r\n        label.zIndex = 2;\r\n        this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);\r\n    };\r\n    /**\r\n     * Checks if point is within bounds of a container.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param  {IPoint}   point Point coordinates\r\n     * @return {boolean}         Fits?\r\n     */\r\n    AxisRendererCircular.prototype.fitsToBounds = function (point) {\r\n        return true;\r\n    };\r\n    Object.defineProperty(AxisRendererCircular.prototype, \"startAngle\", {\r\n        /**\r\n         * @return {number} Start angle\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"startAngle\");\r\n        },\r\n        /**\r\n         * Start angle of the axis in degrees (0-360).\r\n         *\r\n         * @param {number}  value  Start angle\r\n         */\r\n        set: function (value) {\r\n            // do not normalize angel here!\r\n            if (this.setPropertyValue(\"startAngle\", value)) {\r\n                this.invalidateAxisItems();\r\n                if (this.axis) {\r\n                    this.axis.invalidateSeries();\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererCircular.prototype, \"endAngle\", {\r\n        /**\r\n         * @return {number} End angle\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"endAngle\");\r\n        },\r\n        /**\r\n         * End angle of the axis in degrees (0-360).\r\n         *\r\n         * @param {number}  value  End angle\r\n         */\r\n        set: function (value) {\r\n            // do not normalize angel here!\r\n            if (this.setPropertyValue(\"endAngle\", value)) {\r\n                this.invalidateAxisItems();\r\n                if (this.axis) {\r\n                    this.axis.invalidateSeries();\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * [getPositionRangePath description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param  {number}  startPosition  Starting position\r\n     * @param  {number}  endPosition    End position\r\n     * @return {string}                 SVG path\r\n     */\r\n    AxisRendererCircular.prototype.getPositionRangePath = function (startPosition, endPosition, radius, innerRadius, cornerRadius) {\r\n        var path = \"\";\r\n        if ($type.isNumber(startPosition) && $type.isNumber(endPosition)) {\r\n            if (!$type.hasValue(radius)) {\r\n                radius = this.radius;\r\n            }\r\n            startPosition = $math.max(startPosition, this.axis.start);\r\n            endPosition = $math.min(endPosition, this.axis.end);\r\n            if (endPosition < startPosition) {\r\n                endPosition = startPosition;\r\n            }\r\n            var pixelRadius = $utils.relativeRadiusToValue(radius, this.pixelRadius);\r\n            var pixelInnerRadius = $utils.relativeRadiusToValue(innerRadius, this.pixelRadius, true);\r\n            var startAngle = this.positionToAngle(startPosition);\r\n            var endAngle = this.positionToAngle(endPosition);\r\n            var arc = endAngle - startAngle;\r\n            path = $path.arc(startAngle, arc, pixelRadius, pixelInnerRadius, pixelRadius, cornerRadius);\r\n        }\r\n        return path;\r\n    };\r\n    /**\r\n     * Returns a new grid element, suitable for this Axis Renderer type.\r\n     *\r\n     * @return {GridCircular} Grid element\r\n     */\r\n    AxisRendererCircular.prototype.createGrid = function () {\r\n        return new GridCircular();\r\n    };\r\n    /**\r\n     * Returns a new fill element, suitable for this Axis Renderer type.\r\n     *\r\n     * @return {AxisFillCircular} Fill element\r\n     */\r\n    AxisRendererCircular.prototype.createFill = function (axis) {\r\n        return new AxisFillCircular(axis);\r\n    };\r\n    /**\r\n     * Returns a new label element, suitable for this Axis Renderer type.\r\n     *\r\n     * @return {AxisLabelCircular} Label element\r\n     */\r\n    AxisRendererCircular.prototype.createLabel = function () {\r\n        return new AxisLabelCircular();\r\n    };\r\n    /**\r\n     * Converts a point at specific coordinates to a relative position (0-1)\r\n     * on the axis.\r\n     *\r\n     * @param  {IPoint}  point  Point\r\n     * @return {number}         Position (0-1)\r\n     */\r\n    AxisRendererCircular.prototype.pointToPosition = function (point) {\r\n        var angle = $math.fitAngleToRange($math.getAngle(point), this.startAngle, this.endAngle);\r\n        return this.coordinateToPosition((angle - this.startAngle) / 360 * this.axisLength);\r\n    };\r\n    return AxisRendererCircular;\r\n}(AxisRenderer));\r\nexport { AxisRendererCircular };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"AxisRendererCircular\"] = AxisRendererCircular;\r\n//# sourceMappingURL=AxisRendererCircular.js.map","/**\r\n * A module defining functionality for circular axis grid elements.\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { Grid } from \"./Grid\";\r\nimport { registry } from \"../../core/Registry\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Creates a circular grid element for circular-type axis.\r\n *\r\n * @see {@link IGridCircularEvents} for a list of available events\r\n * @see {@link IGridCircularAdapters} for a list of available Adapters\r\n * @todo Review: container is better, as we'll be able to attach something to the GridCircular, also with 3d charts we might need some additional elements\r\n */\r\nvar GridCircular = /** @class */ (function (_super) {\r\n    tslib_1.__extends(GridCircular, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function GridCircular() {\r\n        var _this = _super.call(this) || this;\r\n        _this.className = \"GridCircular\";\r\n        _this.pixelPerfect = false;\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(GridCircular.prototype, \"innerRadius\", {\r\n        /**\r\n         * @return {number} Inner radius\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"innerRadius\");\r\n        },\r\n        /**\r\n         * Inner radius of the circular grid. (absolute or relative)\r\n         *\r\n         * @param {number | Percent} value Inner radius\r\n         */\r\n        set: function (value) {\r\n            this.setPercentProperty(\"innerRadius\", value, true, false, 10, false);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(GridCircular.prototype, \"radius\", {\r\n        /**\r\n         * @return {number} Outer radius\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"radius\");\r\n        },\r\n        /**\r\n         * Outer radius of the circular grid. (absolute or relative)\r\n         *\r\n         * @param {number | Percent} value Outer radius\r\n         */\r\n        set: function (value) {\r\n            this.setPercentProperty(\"radius\", value, true, false, 10, false);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return GridCircular;\r\n}(Grid));\r\nexport { GridCircular };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"GridCircular\"] = GridCircular;\r\n//# sourceMappingURL=GridCircular.js.map","/**\r\n * A module for the mini-map control.\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container } from \"../../core/Container\";\r\nimport { Rectangle } from \"../../core/elements/Rectangle\";\r\nimport { List } from \"../../core/utils/List\";\r\nimport { MutableValueDisposer, MultiDisposer } from \"../../core/utils/Disposer\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { color } from \"../../core/utils/Color\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport * as $type from \"../../core/utils/Type\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Creates a \"bird's eye\" view of the whole map.\r\n *\r\n * This control creates a mini-map with the whole of the map, highlighting\r\n * the area which is in the current viewport of the map map.\r\n *\r\n * @see {@link ISmallMapEvents} for a list of available events\r\n * @see {@link ISmallMapAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nvar SmallMap = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SmallMap, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function SmallMap() {\r\n        var _this = \r\n        // Init\r\n        _super.call(this) || this;\r\n        /**\r\n         * A target map.\r\n         *\r\n         * @type {MutableValueDisposer<MapChart>}\r\n         */\r\n        _this._chart = new MutableValueDisposer();\r\n        _this.className = \"SmallMap\";\r\n        // Set defaults\r\n        _this.align = \"left\";\r\n        _this.valign = \"bottom\";\r\n        _this.percentHeight = 20;\r\n        _this.percentWidth = 20;\r\n        _this.margin(5, 5, 5, 5);\r\n        var interfaceColors = new InterfaceColorSet();\r\n        // Set background defailts\r\n        _this.background.fillOpacity = 0.9;\r\n        _this.background.fill = interfaceColors.getFor(\"background\");\r\n        // Set up events\r\n        _this.events.on(\"hit\", _this.moveToPosition, _this, false);\r\n        _this.events.on(\"maxsizechanged\", _this.updateMapSize, _this, false);\r\n        // Create a container\r\n        _this.seriesContainer = _this.createChild(Container);\r\n        _this.seriesContainer.shouldClone = false;\r\n        // Create an outline rectangle\r\n        var rectangle = _this.createChild(Rectangle);\r\n        rectangle.shouldClone = false;\r\n        rectangle.stroke = interfaceColors.getFor(\"alternativeBackground\");\r\n        rectangle.strokeWidth = 1;\r\n        rectangle.strokeOpacity = 0.5;\r\n        rectangle.fill = color(); //\"none\";\r\n        rectangle.verticalCenter = \"middle\";\r\n        rectangle.horizontalCenter = \"middle\";\r\n        rectangle.isMeasured = false;\r\n        _this.rectangle = rectangle;\r\n        _this._disposers.push(_this._chart);\r\n        // Apply theme\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(SmallMap.prototype, \"series\", {\r\n        /**\r\n         * A list of map series used to draw the mini-map.\r\n         *\r\n         * @readonly\r\n         * @return {List<MapSeries>} Series\r\n         */\r\n        get: function () {\r\n            if (!this._series) {\r\n                this._series = new List();\r\n                this._series.events.on(\"inserted\", this.handleSeriesAdded, this, false);\r\n                this._series.events.on(\"removed\", this.handleSeriesRemoved, this, false);\r\n            }\r\n            return this._series;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Decorates a new series when they are pushed into a `series` list.\r\n     *\r\n     * @param {IListEvents<MapSeries>[\"inserted\"]} event Event\r\n     */\r\n    SmallMap.prototype.handleSeriesAdded = function (event) {\r\n        var series = event.newValue;\r\n        if (this.chart.series.contains(series)) {\r\n            var newSeries = series.clone();\r\n            this._series.removeValue(series);\r\n            this._series.push(newSeries);\r\n            series = newSeries;\r\n            this.chart.dataUsers.push(newSeries);\r\n        }\r\n        series.chart = this.chart;\r\n        series.parent = this.seriesContainer;\r\n        series.interactionsEnabled = false;\r\n    };\r\n    /**\r\n     * Cleans up after series are removed from Scrollbar.\r\n     *\r\n     * @param {IListEvents<XYSeries>[\"removed\"]}  event  Event\r\n     */\r\n    SmallMap.prototype.handleSeriesRemoved = function (event) {\r\n        //let sourceSeries: MapSeries = event.oldValue;\r\n        this.invalidate();\r\n    };\r\n    /**\r\n     * Moves main map pan position after click on the small map.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param {AMEvent<Sprite, ISpriteEvents>[\"hit\"]}  event  Event\r\n     */\r\n    SmallMap.prototype.moveToPosition = function (event) {\r\n        var rectPoint = $utils.spritePointToSprite(event.spritePoint, this, this.seriesContainer);\r\n        var geoPoint = this.chart.seriesPointToGeo(rectPoint);\r\n        this.chart.zoomToGeoPoint(geoPoint, this.chart.zoomLevel, true);\r\n    };\r\n    Object.defineProperty(SmallMap.prototype, \"chart\", {\r\n        /**\r\n         * @return {MapChart} Chart/map\r\n         */\r\n        get: function () {\r\n            return this._chart.get();\r\n        },\r\n        /**\r\n         * A chart/map that this control is meant for.\r\n         *\r\n         * @param {MapChart}  chart  Chart/map\r\n         */\r\n        set: function (chart) {\r\n            if (this.chart != chart) {\r\n                this._chart.set(chart, new MultiDisposer([\r\n                    //chart.events.on(\"zoomlevelchanged\", this.updateRectangle, this, false),\r\n                    chart.events.on(\"mappositionchanged\", this.updateRectangle, this, false),\r\n                    chart.events.on(\"scaleratiochanged\", this.updateMapSize, this, false)\r\n                ]));\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Updates the viewport recangle as per current map zoom/pan position.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    SmallMap.prototype.updateRectangle = function () {\r\n        var chart = this.chart;\r\n        var zoomLevel = chart.zoomLevel;\r\n        var rectangle = this.rectangle;\r\n        rectangle.width = this.pixelWidth / zoomLevel;\r\n        rectangle.height = this.pixelHeight / zoomLevel;\r\n        var scale = Math.min(this.percentWidth, this.percentHeight) / 100;\r\n        var seriesContainer = chart.seriesContainer;\r\n        rectangle.x = Math.ceil((zoomLevel * seriesContainer.pixelWidth / 2 - seriesContainer.pixelX) * scale / zoomLevel); // + rectangle.pixelWidth / 2);\r\n        rectangle.y = Math.ceil((zoomLevel * seriesContainer.pixelHeight / 2 - seriesContainer.pixelY) * scale / zoomLevel); // + rectangle.pixelHeight / 2);\r\n        rectangle.validate();\r\n    };\r\n    /**\r\n     * Update map size so that internal elements can redraw themselves after\r\n     * the size of the small map changes.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    SmallMap.prototype.updateMapSize = function () {\r\n        if (this.chart) {\r\n            this.seriesContainer.scale = this.chart.scaleRatio * Math.min(this.percentWidth, this.percentHeight) / 100;\r\n            this.updateRectangle();\r\n            this.afterDraw();\r\n        }\r\n    };\r\n    /**\r\n     * Update elements after drawing the small map.\r\n     */\r\n    SmallMap.prototype.afterDraw = function () {\r\n        _super.prototype.afterDraw.call(this);\r\n        this.seriesContainer.moveTo({ x: this.pixelWidth / 2, y: this.pixelHeight / 2 });\r\n        this.rectangle.maskRectangle = { x: -1, y: -1, width: Math.ceil(this.pixelWidth + 2), height: Math.ceil(this.pixelHeight + 2) };\r\n    };\r\n    /**\r\n     * Processes JSON-based config before it is applied to the object.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param {object}  config  Config\r\n     */\r\n    SmallMap.prototype.processConfig = function (config) {\r\n        if (config) {\r\n            // Set up series\r\n            if ($type.hasValue(config.series) && $type.isArray(config.series)) {\r\n                for (var i = 0, len = config.series.length; i < len; i++) {\r\n                    var series = config.series[i];\r\n                    if ($type.hasValue(series) && $type.isString(series) && this.map.hasKey(series)) {\r\n                        config.series[i] = this.map.getKey(series);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        _super.prototype.processConfig.call(this, config);\r\n    };\r\n    return SmallMap;\r\n}(Container));\r\nexport { SmallMap };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"SmallMap\"] = SmallMap;\r\n//# sourceMappingURL=SmallMap.js.map","/**\r\n * Zoom control module\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container } from \"../../core/Container\";\r\nimport { Button } from \"../../core/elements/Button\";\r\nimport { RoundedRectangle } from \"../../core/elements/RoundedRectangle\";\r\nimport { MutableValueDisposer, MultiDisposer } from \"../../core/utils/Disposer\";\r\nimport { keyboard } from \"../../core/utils/Keyboard\";\r\nimport { getInteraction } from \"../../core/interaction/Interaction\";\r\nimport { percent } from \"../../core/utils/Percent\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Creates a control for zooming the map.\r\n *\r\n * @see {@link IZoomControlEvents} for a list of available events\r\n * @see {@link IZoomControlAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nvar ZoomControl = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ZoomControl, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function ZoomControl() {\r\n        var _this = _super.call(this) || this;\r\n        /**\r\n         * A target map.\r\n         *\r\n         * @type {MutableValueDisposer<MapChart>}\r\n         */\r\n        _this._chart = new MutableValueDisposer();\r\n        _this.className = \"ZoomControl\";\r\n        _this.align = \"right\";\r\n        _this.valign = \"bottom\";\r\n        _this.layout = \"vertical\";\r\n        _this.padding(5, 5, 5, 5);\r\n        var interfaceColors = new InterfaceColorSet();\r\n        var plusButton = _this.createChild(Button);\r\n        plusButton.shouldClone = false;\r\n        plusButton.label.text = \"+\";\r\n        plusButton.width = percent(100);\r\n        plusButton.padding(5, 5, 5, 5);\r\n        //plusButton.fontFamily = \"Verdana\";\r\n        _this.plusButton = plusButton;\r\n        var slider = _this.createChild(Container);\r\n        slider.shouldClone = false;\r\n        slider.width = percent(100);\r\n        slider.background.fill = interfaceColors.getFor(\"alternativeBackground\");\r\n        slider.background.fillOpacity = 0.05;\r\n        slider.background.events.on(\"hit\", _this.handleBackgroundClick, _this, false);\r\n        slider.events.on(\"sizechanged\", _this.updateThumbSize, _this, false);\r\n        _this.slider = slider;\r\n        var thumb = slider.createChild(Button);\r\n        thumb.shouldClone = false;\r\n        thumb.padding(0, 0, 0, 0);\r\n        thumb.draggable = true;\r\n        thumb.events.on(\"drag\", _this.handleThumbDrag, _this, false);\r\n        _this.thumb = thumb;\r\n        var minusButton = _this.createChild(Button);\r\n        minusButton.shouldClone = false;\r\n        minusButton.label.text = \"-\";\r\n        minusButton.padding(5, 5, 5, 5);\r\n        //minusButton.fontFamily = \"Verdana\";\r\n        _this.minusButton = minusButton;\r\n        // Set roles\r\n        _this.thumb.role = \"slider\";\r\n        _this.thumb.readerLive = \"polite\";\r\n        // Set reader text\r\n        _this.thumb.readerTitle = _this.language.translate(\"Use arrow keys to zoom in and out\");\r\n        _this.minusButton.readerTitle = _this.language.translate(\"Press ENTER to zoom in\");\r\n        _this.plusButton.readerTitle = _this.language.translate(\"Press ENTER to zoom out\");\r\n        _this.applyTheme();\r\n        _this.events.on(\"propertychanged\", function (event) {\r\n            if (event.property == \"layout\") {\r\n                _this.fixLayout();\r\n            }\r\n        }, undefined, false);\r\n        _this._disposers.push(_this._chart);\r\n        _this.fixLayout();\r\n        return _this;\r\n    }\r\n    ZoomControl.prototype.fixLayout = function () {\r\n        if (this.layout == \"vertical\") {\r\n            this.width = 40;\r\n            this.height = undefined;\r\n            this.minusButton.width = percent(100);\r\n            this.thumb.width = percent(100);\r\n            this.plusButton.width = percent(100);\r\n            this.slider.width = percent(100);\r\n            this.minusButton.marginTop = 1;\r\n            this.plusButton.marginBottom = 2;\r\n            this.slider.height = 0;\r\n            this.minusButton.toFront();\r\n            this.plusButton.toBack();\r\n            this.thumb.minX = 0;\r\n            this.thumb.maxX = 0;\r\n            this.thumb.minY = 0;\r\n        }\r\n        else if (this.layout == \"horizontal\") {\r\n            this.thumb.minX = 0;\r\n            this.thumb.minY = 0;\r\n            this.thumb.maxY = 0;\r\n            this.height = 40;\r\n            this.width = undefined;\r\n            this.minusButton.height = percent(100);\r\n            this.minusButton.width = 30;\r\n            this.thumb.height = percent(100);\r\n            this.thumb.width = undefined;\r\n            this.plusButton.height = percent(100);\r\n            this.plusButton.width = 30;\r\n            this.slider.height = percent(100);\r\n            this.slider.width = 0;\r\n            this.minusButton.marginLeft = 2;\r\n            this.plusButton.marginRight = 2;\r\n            this.minusButton.toBack();\r\n            this.plusButton.toFront();\r\n        }\r\n    };\r\n    /**\r\n     * Handles zoom operation after clicking on the slider background.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param {AMEvent<Sprite, ISpriteEvents>[\"hit\"]}  event  Event\r\n     */\r\n    ZoomControl.prototype.handleBackgroundClick = function (event) {\r\n        var sprite = event.target;\r\n        var y = event.spritePoint.y;\r\n        var chart = this.chart;\r\n        var maxPower = Math.log(chart.maxZoomLevel) / Math.LN2;\r\n        var minPower = Math.log(chart.minZoomLevel) / Math.LN2;\r\n        var power = (sprite.pixelHeight - y) / sprite.pixelHeight * (minPower + (maxPower - minPower));\r\n        var zoomLevel = Math.pow(2, power);\r\n        chart.zoomToGeoPoint(chart.zoomGeoPoint, zoomLevel);\r\n    };\r\n    Object.defineProperty(ZoomControl.prototype, \"chart\", {\r\n        /**\r\n         * @return {MapChart} Map/chart\r\n         */\r\n        get: function () {\r\n            return this._chart.get();\r\n        },\r\n        /**\r\n         * A main chart/map that this zoom control is for.\r\n         *\r\n         * @param {MapChart}  chart  Map/chart\r\n         */\r\n        set: function (chart) {\r\n            var _this = this;\r\n            this._chart.set(chart, new MultiDisposer([\r\n                chart.events.on(\"maxsizechanged\", this.updateThumbSize, this, false),\r\n                chart.events.on(\"zoomlevelchanged\", this.updateThumb, this, false),\r\n                this.minusButton.events.on(\"hit\", function () { chart.zoomOut(chart.zoomGeoPoint); }, chart, false),\r\n                getInteraction().body.events.on(\"keyup\", function (ev) {\r\n                    if (_this.topParent.hasFocused) {\r\n                        if (keyboard.isKey(ev.event, \"enter\")) {\r\n                            if (_this.minusButton.isFocused) {\r\n                                chart.zoomOut();\r\n                            }\r\n                            else if (_this.plusButton.isFocused) {\r\n                                chart.zoomIn();\r\n                            }\r\n                        }\r\n                        else if (keyboard.isKey(ev.event, \"plus\")) {\r\n                            chart.zoomIn();\r\n                        }\r\n                        else if (keyboard.isKey(ev.event, \"minus\")) {\r\n                            chart.zoomOut();\r\n                        }\r\n                    }\r\n                }, chart),\r\n                this.plusButton.events.on(\"hit\", function () { chart.zoomIn(chart.zoomGeoPoint); }, chart, false)\r\n            ]));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Updates the slider's thumb size based on the available zoom space.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    ZoomControl.prototype.updateThumbSize = function () {\r\n        var chart = this.chart;\r\n        if (chart) {\r\n            var slider = this.slider;\r\n            var thumb = this.thumb;\r\n            if (this.layout == \"vertical\") {\r\n                thumb.minHeight = Math.min(this.slider.pixelHeight, 20);\r\n                thumb.height = slider.pixelHeight / this.stepCount;\r\n                thumb.maxY = slider.pixelHeight - thumb.pixelHeight;\r\n                if (thumb.pixelHeight <= 1) {\r\n                    thumb.visible = false;\r\n                }\r\n                else {\r\n                    thumb.visible = true;\r\n                }\r\n            }\r\n            else {\r\n                thumb.minWidth = Math.min(this.slider.pixelWidth, 20);\r\n                thumb.width = slider.pixelWidth / this.stepCount;\r\n                thumb.maxX = slider.pixelWidth - thumb.pixelWidth;\r\n                if (thumb.pixelWidth <= 1) {\r\n                    thumb.visible = false;\r\n                }\r\n                else {\r\n                    thumb.visible = true;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Updates thumb according to current zoom position from map.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    ZoomControl.prototype.updateThumb = function () {\r\n        var slider = this.slider;\r\n        var chart = this.chart;\r\n        var thumb = this.thumb;\r\n        if (!thumb.isDown) {\r\n            var step = (Math.log(chart.zoomLevel) - Math.log(this.chart.minZoomLevel)) / Math.LN2;\r\n            if (this.layout == \"vertical\") {\r\n                thumb.y = slider.pixelHeight - (slider.pixelHeight - thumb.pixelHeight) * step / this.stepCount - thumb.pixelHeight;\r\n            }\r\n            else {\r\n                thumb.x = slider.pixelWidth * step / this.stepCount;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Zooms the actual map when slider position changes.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    ZoomControl.prototype.handleThumbDrag = function () {\r\n        var slider = this.slider;\r\n        var chart = this.chart;\r\n        var thumb = this.thumb;\r\n        var step;\r\n        var minStep = Math.log(this.chart.minZoomLevel) / Math.LN2;\r\n        if (this.layout == \"vertical\") {\r\n            step = this.stepCount * (slider.pixelHeight - thumb.pixelY - thumb.pixelHeight) / (slider.pixelHeight - thumb.pixelHeight);\r\n        }\r\n        else {\r\n            step = this.stepCount * thumb.pixelX / slider.pixelWidth;\r\n        }\r\n        step = minStep + step;\r\n        var zoomLevel = Math.pow(2, step);\r\n        chart.zoomToGeoPoint(undefined, zoomLevel, false, 0);\r\n    };\r\n    Object.defineProperty(ZoomControl.prototype, \"stepCount\", {\r\n        /**\r\n         * Returns the step countfor the slider grid according to map's min and max\r\n         * zoom level settings.\r\n         *\r\n         * @ignore Exclude from docs\r\n         * @return {number} Step count\r\n         */\r\n        get: function () {\r\n            return Math.log(this.chart.maxZoomLevel) / Math.LN2 - Math.log(this.chart.minZoomLevel) / Math.LN2;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Creates a background element for slider control.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return {this} Background\r\n     */\r\n    ZoomControl.prototype.createBackground = function () {\r\n        return new RoundedRectangle();\r\n    };\r\n    return ZoomControl;\r\n}(Container));\r\nexport { ZoomControl };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"ZoomControl\"] = ZoomControl;\r\n//# sourceMappingURL=ZoomControl.js.map","/**\r\n * Defines default Responsive rules\r\n * @hidden\r\n */\r\nimport { AxisRenderer } from \"../../charts/axes/AxisRenderer\";\r\nimport { AxisRendererX } from \"../../charts/axes/AxisRendererX\";\r\nimport { AxisRendererY } from \"../../charts/axes/AxisRendererY\";\r\nimport { AxisRendererCircular } from \"../../charts/axes/AxisRendererCircular\";\r\nimport { Chart } from \"../../charts/Chart\";\r\nimport { Legend } from \"../../charts/Legend\";\r\nimport { SmallMap } from \"../../charts/map/SmallMap\";\r\nimport { ZoomControl } from \"../../charts/map/ZoomControl\";\r\n/**\r\n * ============================================================================\r\n * RULES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Default rules.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Do not create states for objects that do not have any overrides\r\n */\r\nexport default [\r\n    /**\r\n     * --------------------------------------------------------------------------\r\n     * Microcharts and sparklines\r\n     * W<=100 || H<=100\r\n     * @todo\r\n     */\r\n    {\r\n        relevant: function (container) {\r\n            if ((container.pixelWidth <= 100) || (container.pixelHeight <= 100)) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        state: function (object, stateId) {\r\n            // Put vertical axis labels inside\r\n            if (object instanceof AxisRenderer) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.minLabelPosition = 1;\r\n                state.properties.maxLabelPosition = 0;\r\n                return state;\r\n            }\r\n        }\r\n    },\r\n    /**\r\n     * --------------------------------------------------------------------------\r\n     * Narrow\r\n     * W<=200\r\n     */\r\n    {\r\n        relevant: function (container) {\r\n            if ((container.pixelWidth <= 200)) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        state: function (object, stateId) {\r\n            // Put vertical axis labels inside\r\n            if (object instanceof AxisRendererY) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.inside = true;\r\n                return state;\r\n            }\r\n            if (object instanceof AxisRendererCircular) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.inside = true;\r\n                return state;\r\n            }\r\n            if (object instanceof SmallMap) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.disabled = true;\r\n                return state;\r\n            }\r\n            /*if (object instanceof Container && object.parent instanceof ZoomControl && !(object instanceof Button)) {\r\n                let state = object.states.create(stateId);\r\n                state.properties.height = 0;\r\n                return state;\r\n            }*/\r\n            if (object instanceof ZoomControl) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.layout = \"vertical\";\r\n                return state;\r\n            }\r\n            if (object instanceof Chart) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.marginLeft = 0;\r\n                state.properties.marginRight = 0;\r\n                return state;\r\n            }\r\n            if (object instanceof Legend && (object.position == \"left\" || object.position == \"right\")) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.position = \"bottom\";\r\n                return state;\r\n            }\r\n        }\r\n    },\r\n    /**\r\n     * --------------------------------------------------------------------------\r\n     * Short\r\n     * H<=200\r\n     */\r\n    {\r\n        relevant: function (container) {\r\n            if ((container.pixelHeight <= 200)) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        state: function (object, stateId) {\r\n            // Put vertical axis labels inside\r\n            if (object instanceof AxisRendererX) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.inside = true;\r\n                return state;\r\n            }\r\n            if (object instanceof AxisRendererCircular) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.inside = true;\r\n                return state;\r\n            }\r\n            if (object instanceof SmallMap) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.disabled = true;\r\n                return state;\r\n            }\r\n            /*if (object instanceof Container && object.parent instanceof ZoomControl && !(object instanceof Button)) {\r\n                let state = object.states.create(stateId);\r\n                state.properties.width = 100;\r\n                return state;\r\n            }*/\r\n            if (object instanceof ZoomControl) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.layout = \"horizontal\";\r\n                return state;\r\n            }\r\n            if (object instanceof Chart) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.marginTop = 0;\r\n                state.properties.marginBottom = 0;\r\n                return state;\r\n            }\r\n            if (object instanceof Legend && (object.position == \"bottom\" || object.position == \"top\")) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.position = \"right\";\r\n                return state;\r\n            }\r\n        }\r\n    },\r\n    /**\r\n     * --------------------------------------------------------------------------\r\n     * Super-small\r\n     * W<=200 && H<=200\r\n     */\r\n    {\r\n        relevant: function (container) {\r\n            if ((container.pixelWidth <= 200) && (container.pixelHeight <= 200)) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        state: function (object, stateId) {\r\n            // Hide legend\r\n            if (object instanceof Legend) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.disabled = true;\r\n                return state;\r\n            }\r\n            if (object instanceof ZoomControl) {\r\n                var state = object.states.create(stateId);\r\n                state.properties.disabled = true;\r\n                return state;\r\n            }\r\n        }\r\n    }\r\n];\r\n//# sourceMappingURL=ResponsiveDefaults.js.map"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7OA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/aA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}